{{- if .Values.gui.enabled }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wekaappstoregui-deployment
  labels:
    app: wekaappstoregui
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wekaappstoregui
  template:
    metadata:
      labels:
        app: wekaappstoregui
    spec:
      serviceAccountName: {{ include "weka-app-store-operator-chart.serviceAccountName" . }}
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
      volumes:
        - name: manifests
          emptyDir: {}
      initContainers:
        - name: git-sync
          image: registry.k8s.io/git-sync/git-sync:v4.5.0
          imagePullPolicy: IfNotPresent
          args:
            - "--repo=https://github.com/weka/warp-blueprints.git"
            - "--root=/manifests"
            - "--link=manifests"
            - "--one-time"
          volumeMounts:
              - { name: manifests, mountPath: /manifests }
      containers:
        - name: wekaappstoregui
          image: wekachrisjen/weka-app-store-gui:v0.27
          volumeMounts:
            - name: manifests
              mountPath: /app/manifests
              subPath: manifests
              readOnly: true
            - name: manifests
              mountPath: /manifests
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8000
          env:
            - name: UVICORN_WORKERS
              value: "1"
            # Explicitly point the app to the mounted repo root. The app will
            # also auto-detect an inner 'manifests/' directory if present.
            - name: BLUEPRINTS_DIR
              value: "/app/manifests"
            - name: GIT_SYNC_REPO
              value: "https://github.com/weka/warp-blueprints.git"
            - name: GIT_SYNC_BRANCH
              value: "main"
            - name: GIT_SYNC_ROOT
              value: "/manifests"
            - name: GIT_SYNC_LINK
              value: "manifests"
            - name: SYNC_TOKEN
              value: ""
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8000
            initialDelaySeconds: 2
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"
---
apiVersion: v1
kind: Service
metadata:
  name: wekaappstoregui-svc
  labels:
    app: wekaappstoregui
spec:
  type: ClusterIP
  selector:
    app: wekaappstoregui
  ports:
    - name: http
      port: 80
      targetPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: wekaappstoregui-lb
  labels:
    app: wekaappstoregui
  # --- (Optional) provider-specific knobs shown below in comments ---
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"                 # create an NLB
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"   # external LB
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"       # target pods directly
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    # (optional) pin to specific subnets; otherwise rely on subnet tags
    service.beta.kubernetes.io/aws-load-balancer-subnets: "subnet-0ec601f62aeb0d8f7,subnet-0a805aa002262cf4a"
    # (optional) enable Proxy Protocol v2 if your app/ingress inside expects it
    # service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"
  #
  #   # GKE (external; defaults are fineâ€”annotations typically not needed)
  #   # cloud.google.com/neg: '{"ingress": false}'                              # leave off unless you need NEGs
  #
  #   # Azure
  #   # service.beta.kubernetes.io/azure-load-balancer-internal: "false"        # "true" for internal LB
  #   # service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: "/healthz"
spec:
  type: LoadBalancer
  selector:
    app: wekaappstoregui
  ports:
    - name: http
      port: 80            # external LB port
      targetPort: 8000    # your container's port
      protocol: TCP
  # Keep the client source IP and let cloud LB health-check node ports.
  # If you set Local, be sure at least one pod is on each node that receives traffic.
  externalTrafficPolicy: Cluster
  # To restrict who can hit the LB (CIDR allowlist), uncomment:
  # loadBalancerSourceRanges:
  #   - 0.0.0.0/0
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: wekaappstoregui-sa
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: wekaappstoregui-view
# NOTE:
# - ClusterRoleBinding is cluster-scoped, but ServiceAccount subjects are namespaced.
# - The namespace below MUST match the namespace where the ServiceAccount 'wekaappstoregui-sa' is created.
# - If you deploy this manifest to a namespace other than 'default', change 'subjects[0].namespace' to that namespace.
# - Do NOT omit the namespace field for a ServiceAccount subject; it is required. If you want a namespace-agnostic binding,
#   consider binding the ClusterRole to a GROUP instead (e.g., 'system:serviceaccounts' to grant to all ServiceAccounts),
#   but that broadens access cluster-wide and is generally not recommended.
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
  - kind: ServiceAccount
    name: wekaappstoregui-sa
    namespace: default
---
# Grant the web app permissions to CREATE and DELETE Custom Resources (CRs) in its namespace.
# Notes:
# - Kubernetes RBAC cannot target only "custom" resources explicitly. Using apiGroups: ["*"] covers
#   all named API groups (which includes CRDs' groups and most non-core groups) but does NOT include
#   the core API group "". This is a pragmatic way to allow managing CRs without broad core access.
# - This Role is NAMESPACE-SCOPED. It enables managing namespaced CRs within the namespace where the
#   app is deployed. If you deploy to a namespace other than 'default', update all 'metadata.namespace'
#   and the subject namespace fields accordingly.
# - If you also need to manage CLUSTER-SCOPED custom resources, a ClusterRole and ClusterRoleBinding
#   would be required (broader privileges). Not added here to keep scope minimal.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: wekaappstoregui-cr-manager
  namespace: default
rules:
  - apiGroups: ["*"]   # all named (non-core) API groups; commonly where CRs live
    resources: ["*"]   # all resources in those API groups
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete", "deletecollection"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: wekaappstoregui-cr-manager
  namespace: default
subjects:
  - kind: ServiceAccount
    name: wekaappstoregui-sa
    namespace: default  # must match the SA namespace
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: wekaappstoregui-cr-manager

---
# Cluster-wide read-only permissions required by the web app to display cluster information
# This complements the built-in 'view' role by adding access to cluster-scoped resources
# that 'view' does not cover (e.g., nodes, namespaces, storageclasses, CRDs).
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: wekaappstoregui-read-cluster
rules:
  # Core resources needed by main.py (list nodes for CPU/GPU info; list namespaces for readiness check)
  - apiGroups: [""]
    resources: ["nodes", "namespaces", "pods"]
    verbs: ["get", "list", "watch"]
  # Storage classes (default StorageClass detection)
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  # CRDs (to detect whether the WekaAppStore CRD is installed)
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list", "watch"]
  # Read custom resources across groups for display-only purposes (no mutations here)
  - apiGroups: ["*"]
    resources: ["*"]
    verbs: ["get", "list", "watch"]
    # Note: This grants read-only across all named API groups, enabling the UI to enumerate CRs
    # for status. Mutations remain restricted to the namespace-scoped Role above.
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: wekaappstoregui-read-cluster
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: wekaappstoregui-read-cluster
subjects:
  - kind: ServiceAccount
    name: wekaappstoregui-sa
    namespace: default  # must match the ServiceAccount namespace
---
# Write permissions required to submit blueprints and initialize/un-initialize the cluster.
# This grants the web app the ability to:
# - Create target namespaces when they don't exist (ensure_namespace_exists in main.py)
# - Create/patch/delete ConfigMaps used as valuesFiles across namespaces
# - Create/patch/delete the WekaAppStore CRs (warp.io) and legacy Warrp CRs (warrp.io)
# Scope: cluster-wide for the specific resources below to allow operating in any namespace.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: wekaappstoregui-apply
rules:
  # Core: allow managing ConfigMaps anywhere (values files for Helm releases)
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  # Core: allow creating namespaces if missing (idempotent); no delete to be safe
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list", "watch", "create"]
  # Weka/Warrp CRs: allow managing the CR that the app submits
  - apiGroups: ["warp.io"]
    resources: ["wekaappstores"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  - apiGroups: ["warrp.io"]
    resources: ["warrpappstores"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: wekaappstoregui-apply
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: wekaappstoregui-apply
subjects:
  - kind: ServiceAccount
    name: wekaappstoregui-sa
    namespace: default  # must match the ServiceAccount namespace

{{- end }}