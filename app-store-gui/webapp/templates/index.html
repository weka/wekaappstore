<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WEKA App Store</title>
  {% if logo_b64 %}
    <link rel="icon" type="image/png" href="data:image/png;base64,{{ logo_b64 }}">
  {% endif %}
  <!-- Inter font for professional typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <!-- TailwindCSS via CDN for simplicity -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + MUI via CDN (no build step required) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@emotion/react@11.11.4/dist/emotion-react.umd.min.js" crossorigin></script>
  <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin></script>
  <script src="https://unpkg.com/@mui/material@5.15.14/umd/material-ui.development.js" crossorigin></script>
  <style>
    :root { --weka-purple: #6b2fb3; --weka-purple-dark: #552695; --weka-dark: #0B0C10; }

    body { background: #0b0c10; color: #e5e7eb; font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji'; }

    .brand-grad { background: linear-gradient(135deg, #0b0c10 0%, #111827 40%, #0b0c10 100%); }
    .card { background: rgba(31, 41, 55, 0.55); border: 1px solid rgba(255,255,255,0.06); backdrop-filter: blur(8px); }

    .btn-purple { background: var(--weka-purple); color: white; }
    .btn-purple:hover { background: var(--weka-purple-dark); }
    .btn-outline { border: 1px solid rgba(255,255,255,0.2); color: #e5e7eb; }
    .btn-outline:hover { background: rgba(255,255,255,0.06); }

    .muted { color: #9ca3af; }
    .status-dot { width: 10px; height: 10px; border-radius: 9999px; display: inline-block; margin-left: 8px; }

    /* Subtle background orbs for a Hyperstack-like glow */
    .bg-orb { position: absolute; filter: blur(80px); opacity: 0.4; pointer-events: none; }
    .orb-purple { background: radial-gradient(closest-side, rgba(107,47,179,0.6), transparent 70%); }
    .orb-blue { background: radial-gradient(closest-side, rgba(59,130,246,0.25), transparent 70%); }
  </style>
</head>
<body class="min-h-screen">
  <header class="brand-grad border-b border-white/10">
    <div class="max-w-6xl mx-auto px-4 py-6 flex items-center justify-between">
      <div class="flex items-center gap-3">
        {% if logo_b64 %}
          <img src="data:image/png;base64,{{ logo_b64 }}" alt="WEKA App Store" class="w-8 h-8 rounded-sm object-contain bg-white/0" />
        {% else %}
          <div class="w-8 h-8 rounded-sm" style="background: var(--weka-purple);"></div>
        {% endif %}
        <h1 class="text-2xl font-semibold tracking-tight">WEKA App Store</h1>
      </div>
      <nav class="flex items-center gap-6 text-sm">
        <a href="/" class="text-white/80 hover:text-white">Home</a>
        <a href="/settings" class="text-white/80 hover:text-white">Settings</a>
      </nav>
    </div>
  </header>

  <main class="relative overflow-hidden">
    <!-- background orbs -->
    <div class="absolute inset-0 -z-10">
      <div class="bg-orb orb-purple w-[420px] h-[420px] rounded-full" style="top:-120px; left:-120px;"></div>
      <div class="bg-orb orb-blue w-[520px] h-[520px] rounded-full" style="bottom:-160px; right:-160px;"></div>
    </div>

    <!-- Hero -->
    <section class="max-w-6xl mx-auto px-4 pt-14 pb-8">
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 items-center">
        <div class="lg:col-span-7">
          <h1 class="text-4xl md:text-5xl font-semibold leading-tight">
            Operate AI apps on Kubernetes with
            <span class="bg-clip-text text-transparent" style="background-image: linear-gradient(90deg, var(--weka-purple) 0%, #a855f7 50%, #60a5fa 100%);">WEKA performance</span>
          </h1>
          <p class="muted mt-4 max-w-2xl">
            A curated catalog of blueprints that deploy battleâ€‘tested AI uses cases into your Kubernetes cluster.
            Built on Open Source and NVIDIA tooling optimised for NeuralMesh by WEKA.
          </p>
          <div class="mt-6 flex items-center gap-3">
            <a href="#catalog" class="btn-purple px-5 py-2.5 rounded-md text-sm font-medium shadow-sm">Explore Blueprints</a>
            <a href="/settings" class="btn-outline px-5 py-2.5 rounded-md text-sm font-medium">Settings</a>
          </div>
        </div>
        <div class="lg:col-span-5">
          <div class="card rounded-xl p-6 border-white/10">
            <div class="text-sm muted mb-2">Cluster connection</div>
            <div class="flex items-center justify-between mb-3">
              <div class="flex items-center gap-2">
                <span id="auth-status-dot" class="status-dot bg-gray-500"></span>
                <span id="auth-status-text" class="text-white/90 text-sm">Checking...</span>
              </div>
              <a href="/settings" class="text-xs text-white/70 hover:text-white">Configure</a>
            </div>
            <div class="mt-2">
              <label for="namespace-select" class="block text-xs muted mb-1">Namespace</label>
              <select id="namespace-select" class="w-full px-3 py-2 rounded-md bg-gray-800/70 border border-white/10 focus:outline-none focus:ring-2 focus:ring-purple-600">
                <option value="" disabled selected>Loading namespaces...</option>
              </select>
              <div id="namespace-error" class="text-xs text-red-400 mt-2 hidden"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="catalog" class="max-w-6xl mx-auto px-4 py-8 space-y-6">
      <div class="flex items-end justify-between mb-4">
        <div>
          <h2 class="text-xl font-semibold">App Catalog</h2>
          <p class="muted text-sm">Choose an application to deploy to your Kubernetes cluster.</p>
        </div>
      </div>
      <div id="catalog-root"></div>
      <script>
        (function(){
          const { createElement: h, useMemo } = React;
          const { createRoot } = ReactDOM;
          const {
            createTheme,
            ThemeProvider,
            CssBaseline,
            Card,
            CardContent,
            CardActions,
            CardActionArea,
            Typography,
            Button,
            Grid,
            Box,
            Chip,
            Stack
          } = MaterialUI;

          const theme = createTheme({
            palette: {
              mode: 'dark',
              primary: { main: getComputedStyle(document.documentElement).getPropertyValue('--weka-purple').trim() || '#6b2fb3' },
              background: { default: '#0b0c10', paper: 'rgba(31,41,55,0.6)' },
              text: { primary: '#e5e7eb', secondary: '#9ca3af' }
            },
            typography: {
              fontFamily: 'Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
              h6: { fontWeight: 600 }
            },
            shape: { borderRadius: 12 },
            components: {
              MuiCard: {
                styleOverrides: {
                  root: {
                    border: '1px solid rgba(255,255,255,0.06)',
                    backdropFilter: 'blur(8px)',
                    transition: 'transform .2s ease, border-color .2s ease, box-shadow .2s ease',
                  }
                }
              },
              MuiButton: {
                styleOverrides: {
                  root: { textTransform: 'none', borderRadius: 10 }
                }
              },
              MuiChip: {
                styleOverrides: { root: { background: 'rgba(255,255,255,0.06)', color: '#e5e7eb' } }
              }
            }
          });

          const items = [
            {
              title: 'Enterprise Search and Retrieval Augmented Generation (RAG)',
              desc: 'Deploy an open-source search and summary stack to your cluster for enterprise-grade semantic search and summarization. Utilising leading tools like vLLM and Milvus ',
              href: '/blueprint/oss-rag',
              tags: ['Open Source']
            },
            {
              title: 'Enterprise Search and Retrieval Augmented Generation (RAG)',
              desc: 'NVIDIA-optimized search and summary stack for high-performance enterprise search and summarization. This is based on NVIDIA NIM framework',
              href: '/blueprint/nvidia-rag',
              tags: ['NVIDIA'],
              comingSoon: true
            },
            {
              title: 'Video Search and Summary',
              desc: 'Video search catalog and summarisation with NVIDIA NIM framework. With added customisation for NeuralMesh by WEKA to support high stream counts',
              href: '/blueprint/nvidia-vss',
              tags: ['NVIDIA'],
              comingSoon: true
            },
            {
              title: 'Openfold Protein Prediction',
              desc: 'OpenFold is an open-source, AI-powered software tool that predicts the 3D structures of proteins from their amino acid sequences.',
              href: '/blueprint/openfold',
              tags: ['Open Source']
            },
            {
              title: 'AI Agent for Enterprise Research',
              desc: 'This will build an AI Agent that conducts Research on your domain specific data summarising and conducting research.',
              href: '/blueprint/ai-agent-enterprise-research',
              tags: ['NVIDIA'],
              comingSoon: true
            }
          ];

          function Catalog(){
            return h(ThemeProvider, { theme },
              h(CssBaseline, null),
              h(Box, { sx: { flexGrow: 1 } },
                h(Grid, { container: true, spacing: 2.5, alignItems: 'stretch' },
                  items.map((it, idx) => h(Grid, { item: true, xs: 12, md: 4, key: idx },
                    h(Card, { elevation: 0, sx: { position: 'relative', display: 'flex', flexDirection: 'column', height: '100%', ':hover': { transform: 'translateY(-2px)', borderColor: 'primary.main', boxShadow: '0 10px 20px rgba(0,0,0,0.25)' } } },
                      it.comingSoon && h(Box, { sx: {
                        position: 'absolute',
                        top: 36,
                        right: -24,
                        transform: 'rotate(45deg)',
                        background: 'linear-gradient(90deg, #6b2fb3 0%, #a855f7 100%)',
                        color: '#fff',
                        px: 3,
                        py: 0.5,
                        fontSize: 11,
                        fontWeight: 700,
                        letterSpacing: 1,
                        textTransform: 'uppercase',
                        boxShadow: '0 6px 14px rgba(0,0,0,0.35)',
                        borderRadius: 1,
                        pointerEvents: 'none'
                      } }, 'Coming Soon'),
                      h(CardActionArea, { component: 'a', href: it.href, sx: { flexGrow: 1, alignItems: 'stretch' } },
                        h(CardContent, { sx: { display: 'flex', flexDirection: 'column', flexGrow: 1 } },
                          h(Stack, { direction: 'row', spacing: 1, sx: { mb: 1 } },
                            ...(it.tags || []).map((t, i) => h(Chip, { key: i, size: 'small', label: t }))
                          ),
                          h(Typography, { variant: 'h6', component: 'h3', sx: { mt: 0.5 } }, it.title),
                          h(Typography, { variant: 'body2', sx: { color: 'text.secondary', mt: 1 } }, it.desc)
                        )
                      ),
                      h(CardActions, { sx: { mt: 'auto', p: 2 } },
                        it.comingSoon
                          ? h(Button, {
                              variant: 'contained',
                              color: 'primary',
                              size: 'small',
                              disabled: true,
                              sx: { pointerEvents: 'none', opacity: 0.8 }
                            }, 'Learn More & Install')
                          : h(Button, { variant: 'contained', color: 'primary', size: 'small', href: it.href }, 'Learn More & Install')
                      )
                    )
                  ))
                )
              )
            );
          }

          const rootEl = document.getElementById('catalog-root');
          if (rootEl) {
            const root = createRoot(rootEl);
            root.render(h(Catalog));
          }
        })();
      </script>
    </section>

  </main>

  <footer class="max-w-6xl mx-auto px-4 py-8 muted text-xs">
  </footer>

  <script>
    async function post(url, data) {
      const options = data ? { method: 'POST', body: data } : { method: 'POST' };
      const res = await fetch(url, options);
      return res.json();
    }

    async function get(url) {
      const res = await fetch(url);
      return res.json();
    }

    async function refreshAuthStatus() {
      try {
        const data = await get('/auth-status');
        const dot = document.getElementById('auth-status-dot');
        const text = document.getElementById('auth-status-text');
        if (!dot || !text) return;
        if (data && data.authenticated) {
          dot.classList.remove('bg-red-500');
          dot.classList.add('bg-green-500');
          text.textContent = 'Connected';
        } else {
          dot.classList.remove('bg-green-500');
          dot.classList.add('bg-red-500');
          text.textContent = 'Not connected';
        }
        // Update tooltip/title with diagnostic message if available
        if (data && data.message) {
          dot.title = data.message;
        }
        // Update details box if present
        const setText = (id, val) => {
          const el = document.getElementById(id);
          if (el) { el.textContent = (val !== undefined && val !== null && val !== '') ? String(val) : '-'; }
        };
        setText('auth-detail-mode', data?.mode);
        setText('auth-detail-source', data?.details?.source);
        // For server we also update the title attribute
        const serverEl = document.getElementById('auth-detail-server');
        if (serverEl) {
          const v = data?.details?.server;
          serverEl.textContent = (v ? String(v) : '-');
          serverEl.title = v ? String(v) : '';
        }
        setText('auth-detail-context', data?.details?.context);
        setText('auth-detail-namespace', data?.details?.namespace);
        setText('auth-detail-user', data?.details?.user);
        setText('auth-detail-message', data?.message);
      } catch (e) {
        const dot = document.getElementById('auth-status-dot');
        const text = document.getElementById('auth-status-text');
        if (dot) { dot.classList.remove('bg-green-500'); dot.classList.add('bg-red-500'); dot.title = String(e); }
        if (text) { text.textContent = 'Not connected'; }
        const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = '-'; };
        ['auth-detail-mode','auth-detail-source','auth-detail-server','auth-detail-context','auth-detail-namespace','auth-detail-user','auth-detail-message'].forEach(id => setText(id, '-'));
      }
    }

    // Populate namespaces dropdown
    async function loadNamespaces() {
      const sel = document.getElementById('namespace-select');
      const errEl = document.getElementById('namespace-error');
      if (!sel) return;
      try {
        if (errEl) { errEl.classList.add('hidden'); errEl.textContent = ''; }
        sel.innerHTML = '<option disabled>Loading namespaces...</option>';
        const data = await get('/api/namespaces');
        if (data && data.ok) {
          const names = Array.isArray(data.items) ? data.items : [];
          sel.innerHTML = '';
          if (names.length === 0) {
            sel.innerHTML = '<option disabled selected>No namespaces found</option>';
          } else {
            for (const n of names) {
              const opt = document.createElement('option');
              opt.value = n; opt.textContent = n;
              sel.appendChild(opt);
            }
            // Try to preselect previously chosen namespace from localStorage
            const saved = localStorage.getItem('selectedNamespace');
            if (saved) {
              for (const opt of sel.options) {
                if (opt.value === saved) { sel.value = saved; break; }
              }
            }
          }
          // Persist selection when user changes it
          sel.addEventListener('change', () => {
            const val = sel.value;
            if (val) {
              localStorage.setItem('selectedNamespace', val);
            }
          });
        } else {
          sel.innerHTML = '<option disabled selected>Error loading namespaces</option>';
          if (errEl) { errEl.textContent = data?.error || 'Unknown error'; errEl.classList.remove('hidden'); }
        }
      } catch (e) {
        sel.innerHTML = '<option disabled selected>Error loading namespaces</option>';
        if (errEl) { errEl.textContent = String(e); errEl.classList.remove('hidden'); }
      }
    }

    // Keep auth badge up to date and also sync selected namespace when known
    async function refreshAuthStatus() {
      try {
        const data = await get('/auth-status');
        const dot = document.getElementById('auth-status-dot');
        const text = document.getElementById('auth-status-text');
        if (!dot || !text) return;
        if (data && data.authenticated) {
          dot.classList.remove('bg-red-500');
          dot.classList.add('bg-green-500');
          text.textContent = 'Connected';
        } else {
          dot.classList.remove('bg-green-500');
          dot.classList.add('bg-red-500');
          text.textContent = 'Not connected';
        }
        // Update tooltip/title with diagnostic message if available
        if (data && data.message) {
          dot.title = data.message;
        }
        // Update details box if present
        const setText = (id, val) => {
          const el = document.getElementById(id);
          if (el) { el.textContent = (val !== undefined && val !== null && val !== '') ? String(val) : '-'; }
        };
        setText('auth-detail-mode', data?.mode);
        setText('auth-detail-source', data?.details?.source);
        // For server we also update the title attribute
        const serverEl = document.getElementById('auth-detail-server');
        if (serverEl) {
          const v = data?.details?.server;
          serverEl.textContent = (v ? String(v) : '-');
          serverEl.title = v ? String(v) : '';
        }
        setText('auth-detail-context', data?.details?.context);
        setText('auth-detail-namespace', data?.details?.namespace);
        setText('auth-detail-user', data?.details?.user);
        setText('auth-detail-message', data?.message);

        // If a namespace-select exists, try to pre-select the detected namespace
        const sel = document.getElementById('namespace-select');
        const detected = data?.details?.namespace;
        if (sel && detected) {
          for (const opt of sel.options) {
            if (opt.value === detected) { sel.value = detected; break; }
          }
          // If nothing saved yet, persist the detected namespace for cross-page usage
          if (!localStorage.getItem('selectedNamespace')) {
            localStorage.setItem('selectedNamespace', detected);
          }
        }
      } catch (e) {
        const dot = document.getElementById('auth-status-dot');
        const text = document.getElementById('auth-status-text');
        if (dot) { dot.classList.remove('bg-green-500'); dot.classList.add('bg-red-500'); dot.title = String(e); }
        if (text) { text.textContent = 'Not connected'; }
        const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = '-'; };
        ['auth-detail-mode','auth-detail-source','auth-detail-server','auth-detail-context','auth-detail-namespace','auth-detail-user','auth-detail-message'].forEach(id => setText(id, '-'));
      }
    }

    // Kick off initial loads and poll auth periodically
    loadNamespaces();
    refreshAuthStatus();
    setInterval(refreshAuthStatus, 10000);

    // Initialize Cluster direct deploy
    const initBtn = document.getElementById('init-cluster');
    if (initBtn) {
      initBtn.addEventListener('click', async () => {
        const resEl = document.getElementById('init-result');
        resEl.textContent = 'Submitting cluster initialization...';
        initBtn.disabled = true;
        try {
          const fd = new FormData();
          fd.append('app_name', 'cluster-init');
          fd.append('namespace', 'default'); // ignored by backend for cluster-init
          const data = await post('/deploy', fd);
          if (data.ok) {
            const applied = (data.result && data.result.applied) ? data.result.applied.join(', ') : 'OK';
            resEl.textContent = 'Initialize submitted. Applied: ' + applied + '. Reload the page to refresh status.';
          } else {
            resEl.textContent = 'Error: ' + (data.error || 'Unknown error');
          }
        } catch (e) {
          resEl.textContent = 'Request failed: ' + e;
        } finally {
          initBtn.disabled = false;
        }
      });
    }

    // Un-initialize Cluster
    const uninitBtn = document.getElementById('uninit-cluster');
    if (uninitBtn) {
      uninitBtn.addEventListener('click', async () => {
        const resEl = document.getElementById('init-result');
        resEl.textContent = 'Submitting un-initialize...';
        uninitBtn.disabled = true;
        try {
          const data = await post('/uninit-cluster');
          if (data.ok) {
            resEl.textContent = 'Un-initialize submitted. ' + (data.result ? JSON.stringify(data.result) : 'OK') + '. Reload the page to refresh status.';
          } else {
            resEl.textContent = 'Error: ' + (data.error || 'Unknown error');
          }
        } catch (e) {
          resEl.textContent = 'Request failed: ' + e;
        } finally {
          uninitBtn.disabled = false;
        }
      });
    }
  </script>
</body>
</html>
